import os,json,time,requests
from web3 import Web3
from app_modules.taskLogger import taskLogger
from app_modules.discordLog import webhookLog
from app_modules.apiModules import nodeProvider,etherScanApi,alternative,checkNode,capKey,cfNode,checkCapMonster
from app_modules.titleLog import classUpdateTitle
from app_modules.proxy import proxy_choice
from modules.twitter import manualFollow
import time,re
from eth_account.messages import encode_defunct
from bs4 import BeautifulSoup
import tweepy
import re
import cloudscraper


global web3Connection
updateTitleCall=classUpdateTitle("Premint")
siteKey = "6Lf9yOodAAAAADyXy9cQncsLqD9Gl4NCBx3JCR_x"

class premint():
    def __init__(self,targetUrl,wallet,walletKey,twitterToken,twitterPassword,discordToken,accessToken,accessTokenSecret,consumerKey,consumerSecret,mode,taskId):
       self.targetUrl = targetUrl
       self.wallet = wallet.lower()
       self.walletKey = walletKey
       self.twitterToken = twitterToken
       self.discordToken = discordToken
       self.taskId = taskId
       self.session = None
       self.nonce = None
       self.message = None
       self.signature = None
       self.csrfToken = None
       self.twitterReq = "None"
       self.discordReq = "None"
       self.minimumBalance = None
       self.mode = mode
       self.submitLoad = None
       self.captchaReq = False
       self.first = True
       self.proceed = False
       self.image = "None"
       self.proxy = "None"
       self.name = "None"
       self.password = twitterPassword
       self.params=""
       self.accessToken = accessToken
       self.accessTokenSecret = accessTokenSecret
       self.consumerKey = consumerKey
       self.consumerSecret = consumerSecret
       self.prefix = "@"+twitterToken+","+discordToken
       self.nonce = 0



    def connect(self):
        global web3Connection
        taskLogger({"status" : "process","message":"Connecting to node","prefix":self.prefix},self.taskId)
        web3Connection = Web3(Web3.HTTPProvider(cfNode))
        taskLogger({"status":"success", "message": "Connected to node","prefix":self.prefix},self.taskId)
        updateTitleCall.addRun()
        self.initialize()

    def rotateProxy(self):
        taskLogger({"status":"process", "message": "Rotating proxy","prefix":self.prefix},self.taskId)
        self.session = cloudscraper.create_scraper(
               browser={
                        'browser': 'firefox',
                        'platform': 'windows',
                        'mobile': False
            }
        )
        chosenProxy=proxy_choice()
        self.session.proxies.update(chosenProxy)
        self.proxy = str(self.session.proxies['http'])

    def initialize(self):
        taskLogger({"status" : "process","message":"Initializing session","prefix":self.prefix},self.taskId)
        self.session = cloudscraper.create_scraper()
        
        if (self.mode != "check"):
            self.rotateProxy()
            
        while True:
            try:
                response = self.session.get("http://www.premint.xyz/")
                if (response.status_code == 200):
                    taskLogger({"status" : "process","message":"Initialized session","prefix":self.prefix},self.taskId)
                    matchedToken=re.findall("CSRF_TOKEN = (.*)",response.text)
                    matchedToken = matchedToken[0]
                    matchedToken = matchedToken.replace("\'","")
                    matchedToken = matchedToken.replace(";","")
                    #self.csrfToken = response.cookies['csrftoken']
                    self.csrfToken = matchedToken
                    self.session.headers['X-CSRFToken'] = self.csrfToken
                    self.rotateProxy()
                    break
                else:
                    taskLogger({"status" : "error","message":"Failed initializing session - {}".format(response.status_code),"prefix":self.prefix},self.taskId)
                    self.rotateProxy()
                    #time.sleep(5)
                    
            except Exception as e:
                taskLogger({"status" : "error","message":"Failed initializing session - {}".format(e),"prefix":self.prefix},self.taskId)
                self.rotateProxy()
           
                time.sleep(5)


        if (self.mode != "check"):
            self.verify()
            if (self.proceed):
                self.login()
                self.scrape()
        else:
            self.verify()


    def login(self):
        while (True):
            try:
                taskLogger({"status" : "process","message":"Fetching session","prefix":self.prefix},self.taskId)
                response = self.session.get("https://www.premint.xyz/v1/login_api/")
                if (response.status_code == 200):
                    responseJson = json.loads(response.text)
                    proceed = responseJson['success']
                    if(proceed):
                        self.nonce = responseJson['data']
                        break
                else:
                    taskLogger({"status" : "error","message":"Failed fetching session - {}".format(response.status_code),"prefix":self.prefix},self.taskId)
                    time.sleep(3)
            except Exception as e:
                taskLogger({"status" : "error","message":"Failed fetching session - {}".format(e),"prefix":self.prefix},self.taskId)
                time.sleep(3)

        taskLogger({"status" : "success","message":"Fetched session","prefix":self.prefix},self.taskId)
        msg = "Welcome to PREMINT!" + "\n\n" + "Signing is the only way we can truly know \nthat you are the owner of the wallet you \nare connecting. Signing is a safe, gas-less \ntransaction that does not in any way give \nPREMINT permission to perform any \ntransactions with your wallet." + "\n\n"
        msg = msg+"Wallet address:" + "\n" + self.wallet + "\n\n" +"Nonce: " + self.nonce
        message = encode_defunct(text=msg)
        taskLogger({"status" : "process","message":"Signing session","prefix":self.prefix},self.taskId)
        signed_message = web3Connection.eth.account.sign_message(message, private_key=self.walletKey)
        self.signature = web3Connection.toHex(signed_message['signature'])
        taskLogger({"status" : "success","message":"Signed session","prefix":self.prefix},self.taskId)
        self.authenticate()

    def authenticate(self):
        payload = {
            "web3provider":"metamask",
            "address":self.wallet,
            "signature":self.signature
        }
        self.session.headers['X-CSRFToken'] = self.csrfToken
        self.session.headers['referer'] = self.targetUrl

        while (True):
            try:
                taskLogger({"status" : "process","message":"Logging in","prefix":self.prefix},self.taskId)
                response = self.session.post("https://www.premint.xyz/v1/login_api/",data = payload)
                if (response.status_code == 200):
                    responseJson = json.loads(response.text)
                    proceed = responseJson['success']
                    if(proceed):
                        taskLogger({"status" : "success","message":"Succesfully logged in","prefix":self.prefix},self.taskId)
                        break
                    else:
                        taskLogger({"status" : "error","message":"Failed login - {}".format(responseJson['error']),"prefix":self.prefix},self.taskId)
                        time.sleep(3)
                else:
                    taskLogger({"status" : "error","message":"Failed login - {}".format(response.status_code),"prefix":self.prefix},self.taskId)
                    time.sleep(3)
            except Exception as e:
                taskLogger({"status" : "error","message":"Failed login - {}".format(e),"prefix":self.prefix},self.taskId)
                time.sleep(3)

    def scrape(self): #scrape premint info 
        responseData = None
        while True:
            try:
                response = self.session.get(self.targetUrl)
                if (response.status_code == 200):
                    responseData = response.text
                    taskLogger({"status" : "success","message":"Fetched page","prefix":self.prefix},self.taskId)
                    break
                else:
                    taskLogger({"status" : "error","message":"Failed fetching page - {}".format(response.status_code),"prefix":self.prefix},self.taskId)
                    time.sleep(3)
            except Exception as e:
                taskLogger({"status" : "error","message":"Failed fetching page - {}".format(e),"prefix":self.prefix},self.taskId)
                time.sleep(3)
        
        if ("class=\"g-recaptcha\"" in responseData):
            taskLogger({"status" : "process","message":"Captcha required","prefix":self.prefix},self.taskId)
            self.captchaReq = True
        else:
            pass

        try:
            soup = BeautifulSoup(responseData, "html.parser")
            tokRes = soup.find("input",{"name":"csrfmiddlewaretoken"})
            self.csrfToken = tokRes['value']
        except:
            taskLogger({"status" : "error","message":"Failed fetching token - Disconnected socials","prefix":self.prefix},self.taskId)
            taskObject = {'url':self.targetUrl,'name':self.name,'status': "error",'taskType':"Premint",'statusMessage':'Failed fetching token','wallet':self.wallet,'discord':self.discordToken,'twitter':self.twitterToken,'proxy':self.proxy,'errorMessage':"Disconnected socials",'twitterProj':self.twitterReq,'discordProj':self.discordReq,'image':self.image}
            webhookLog(taskObject)  
            return
        
        #find params here 
        paramRes = soup.find("input",{"name":"params_field"})
        self.params = paramRes['value']

        res = soup.find_all("li",{"class": "mt-1"}) #res = soup.find_all("a",{"class": "c-base-1 strong-700 text-underline"}) #returns links and roles
        for r in res:
            try:
                if ("twitter" in r.a['href']):
                    self.twitterReq = r.a['href']
                    taskLogger({"status" : "process","message":"Found twitter requirement - {}".format(self.twitterReq),"prefix":self.prefix},self.taskId)
                    if (not self.twitterMethod()):
                        return

                elif ("discord" in r.a['href']):
                    self.discordReq = r.a['href']
                    taskLogger({"status" : "process","message":"Found discord requirement - {}".format(self.discordReq),"prefix":self.prefix},self.taskId)
            except:
                pass
        

        res = soup.find("span",{"class":"strong c-black"})
        if (res!= None):
            self.minimumBalance = res.text
            taskLogger({"status" : "process","message":"Found required minimum ETH balance- {}".format(self.minimumBalance),"prefix":self.prefix},self.taskId)

        if (self.discordReq == None):
            taskLogger({"status" : "warn","message":"Could not extract discord invite, skipping","prefix":self.prefix},self.taskId)

        self.submit()

    def requestSolutionMon(self):
        endPoint="https://api.capmonster.cloud/createTask"
        payload = {
                    "clientKey":checkCapMonster(),
                    "task":
                    {
                        "type":"NoCaptchaTask",
                        "websiteURL":self.targetUrl,
                        "websiteKey":"6Lf9yOodAAAAADyXy9cQncsLqD9Gl4NCBx3JCR_x"
                    }
                }

        while True:
            try:
                response=requests.post(endPoint,data = json.dumps(payload))
                if (response.status_code==200):
                    taskLogger({"status" : "process","message":"Beginning solve","prefix":self.prefix},self.taskId)
                    responseJson=json.loads(response.text)
                    if (responseJson['errorId']==0):
                        dataDomeTask=responseJson['taskId']
                        break
                    else:
                        taskLogger({"status" : "error","message":"Failed to create solution task - {}".format(responseJson['errorId']),"prefix":self.prefix},self.taskId)
                        time.sleep(4)
                else:
                    taskLogger({"status" : "error","message":"Failed to request challenge task - {}".format(response.status_code),"prefix":self.prefix},self.taskId)
                    time.sleep(4)
            except Exception as e:
                taskLogger({"status" : "error","message":"Failed to request challenge task - {}".format(e),"prefix":self.prefix},self.taskId)
                time.sleep(5)

        solvedToken=self.getSolutionMon(dataDomeTask)
        self.submitLoad["g-recaptcha-response"] =solvedToken
    
    def getSolutionMon(self,dataDomeTask):
        endPoint = "https://api.capmonster.cloud/getTaskResult"
        payload = {
                    "clientKey":checkCapMonster(),
                    "taskId": dataDomeTask
                }
        while True:
            
            taskLogger({"status" : "process","message":"Solving captcha","prefix":self.prefix},self.taskId)
            try:
                response=requests.post(endPoint,data = json.dumps(payload))
                responseJson=json.loads(response.text)
                if (responseJson["status"]=="ready"):
                    solvedPayload=responseJson
                    taskLogger({"status" : "success","message":"Challenge solved","prefix":self.prefix},self.taskId)
                    break
                time.sleep(5)
            except Exception as e:
                taskLogger({"status" : "error","message":"Failed solving poll - {}".format(e),"prefix":self.prefix},self.taskId)
                time.sleep(7)
        return solvedPayload['solution']['gRecaptchaResponse']

    def submit(self):
        self.submitLoad = {
            "csrfmiddlewaretoken":self.csrfToken,
            "holdings_wallet" : self.wallet,
            "minting_wallet" :self.wallet,
            "params_field":self.params,  #"{\"regdone\":+\"1\"}"
            "registration-form-submit":""}

        '''if (self.mode == "default"):
            self.submitLoad["params_field"] = ""'''
        
        if (self.captchaReq):
            self.requestSolutionMon()

        while True:
            try:
                taskLogger({"status" : "process","message":"Submitting entry","prefix":self.prefix},self.taskId)
                response = self.session.post(self.targetUrl,data = self.submitLoad,allow_redirects = True)
                if (response.status_code ==200):
                    redirect = response.url
                    #if ("regpending" in redirect):
                    time.sleep(2)
                    if (self.verify()):#check if it is submitted
                        updateTitleCall.addSuccess()
                        taskObject = {'url':self.targetUrl,'name':self.name,'status': "success",'taskType':"Premint",'statusMessage':'Successfully submitted entry','wallet':self.wallet,'discord':self.discordToken,'twitter':self.twitterToken,'proxy':self.proxy,'errorMessage':None,'twitterProj':self.twitterReq,'discordProj':self.discordReq,'image':self.image}
                        webhookLog(taskObject)  
                        break
                    else: #extract the error message
                        updateTitleCall.addFail()
                        soup = BeautifulSoup(response.text, "html.parser")
                        res = soup.find("div",{"class":"alert alert-danger alert-dismissible fade show"})
                        taskLogger({"status" : "error","message":"Failed submitting entry - {}".format(res.text),"prefix":self.prefix},self.taskId)
                        taskObject = {'url':self.targetUrl,'name':self.name,'status': "error",'taskType':"Premint",'statusMessage':'Failed submitting entry','wallet':self.wallet,'discord':self.discordToken,'twitter':self.twitterToken,'proxy':self.proxy,'errorMessage':res.text,'twitterProj':self.twitterReq,'discordProj':self.discordReq,'image':self.image}
                        webhookLog(taskObject)  
                        break
                    '''else:
                        updateTitleCall.addFail()
                        taskLogger({"status" : "error","message":"Failed submitting entry, redirect invalid - {}".format(response.url),"prefix":self.prefix},self.taskId)
                        time.sleep(3)'''
                else:
                    updateTitleCall.addFail()
                    taskLogger({"status" : "error","message":"Failed submitting entry - {}".format(response.status_code),"prefix":self.prefix},self.taskId)
                    time.sleep(3)
            except Exception as e:
                updateTitleCall.addFail()
                taskLogger({"status" : "error","message":"Failed submitting entry - {}".format(e),"prefix":self.prefix},self.taskId)
                time.sleep(3)

    
    def verify(self):
        targetUrl = self.targetUrl

        if (self.targetUrl[-1] != "/"):
            targetUrl = self.targetUrl+"/verify"
        else:
            targetUrl = self.targetUrl+"verify"
        

        if (self.mode == "check" or self.first):
            #targetUrl = targetUrl + "/?wallet={}".format(self.wallet)
            targetUrl = targetUrl+"/?wallet={}".format(self.wallet)
            self.first = False

        while True:
            try:
                taskLogger({"status" : "process","message":"Verifying entry","prefix":self.prefix},self.taskId)
                response = self.session.get(targetUrl)
                if (response.status_code == 200):
                    responseData = response.text
                    break
                else:
                    taskLogger({"status" : "error","message":"Failed verification - {}".format(response.status_code),"prefix":self.prefix},self.taskId)
                    time.sleep(3)
            except Exception as e:
                taskLogger({"status" : "error","message":"Failed verification - {}".format(e),"prefix":self.prefix},self.taskId)
                time.sleep(3)

        soup = BeautifulSoup(responseData, "html.parser")
        res = soup.find("div",{"class":"heading heading-3 mb-3"})
        respMessage = res.text
        res = soup.find("img",{"class":"mt-0 bg-white border-white"})
        self.image = res['src']
        res = soup.find("h1",{"class":"heading heading-1"})
        self.name = res.text

        try:
            res = soup.find("div",{"class":"heading heading-1"})  
            respSymbol = res.text
        except:
            res = soup.find("div",{"class":"heading heading-1 mb-3"})  
            respSymbol = res.text

        if ("You aren't registered." in respMessage):
            taskLogger({"status" : "error","message":"Failed verification - {}".format("No entry found for wallet"),"prefix":self.prefix},self.taskId)
            self.proceed = True     
            return False
        elif ("You are registered." in respMessage or respSymbol == "👍"):
            taskLogger({"status" : "success","message":"Verified entry","prefix":self.prefix},self.taskId)
            return True
        elif ("You were not selected!" in respMessage or respSymbol == "😢"): 
            updateTitleCall.addFail()
            taskLogger({"status" : "error","message":"Lost raffle","prefix":self.prefix},self.taskId)
            taskObject = {'url':self.targetUrl,'name':self.name,'status': "error",'taskType':"Premint",'statusMessage':'😢 Lost Raffle 😢','wallet':self.wallet,'discord':self.discordToken,'twitter':self.twitterToken,'proxy':self.proxy,'errorMessage':"You were not selected!",'twitterProj':self.twitterReq,'discordProj':self.discordReq,'image':self.image}
            webhookLog(taskObject)
            return True #we don't want to loop retry for a lost raffle
        elif ("You were selected!" in respMessage or respSymbol =="🏆"):
            updateTitleCall.addSuccess()
            taskLogger({"status" : "success","message":"Won raffle","prefix":self.prefix},self.taskId)
            taskObject = {'url':self.targetUrl,'name':self.name,'status': "success",'taskType':"Premint",'statusMessage':'🏆 Won Raffle 🏆','wallet':self.wallet,'discord':self.discordToken,'twitter':self.twitterToken,'proxy':self.proxy,'errorMessage':"You were selected!",'twitterProj':self.twitterReq,'discordProj':self.discordReq,'image':self.image}
            webhookLog(taskObject)
            return True 
        else:
            taskLogger({"status" : "warn","message":"Unknown response - {}".format(respMessage),"prefix":self.prefix},self.taskId)
            taskObject = {'url':self.targetUrl,'name':self.name,'status': "error",'taskType':"Premint",'statusMessage':'Unknown response','wallet':self.wallet,'discord':self.discordToken,'twitter':self.twitterToken,'proxy':self.proxy,'errorMessage':respMessage,'twitterProj':self.twitterReq,'discordProj':self.discordReq,'image':self.image}
            webhookLog(taskObject)
            self.proceed = True
            return True

    def twitterMethod(self):
        twitterAcc = (self.twitterReq).replace("https://twitter.com/","")
        if (self.password == "api"):
            auth= tweepy.auth.OAuthHandler(self.consumerKey, self.consumerSecret)
            auth.set_access_token(self.accessToken, self.accessTokenSecret)
            api=tweepy.API(auth,retry_count=5,retry_delay=1,retry_errors=set([401, 404, 500, 503]))
            taskLogger({"status" : "process","message":"Following account - @{}".format(self.twitterReq),"prefix":self.prefix},self.taskId)
            api.create_friendship(screen_name=twitterAcc)
            taskLogger({"status" : "success","message":"{} followed account - @{}".format(self.twitterToken,twitterAcc),"prefix":self.prefix},self.taskId)
            return True
        else: #manually login 
            res,message = manualFollow(self.twitterToken,self.password,twitterAcc,self.prefix,self.taskId)
            if (res!= True):
                taskObject = {'url':self.targetUrl,'name':self.targetUrl,'status': "error",'taskType':"Premint",'statusMessage':'Failed twitter follow','wallet':str(self.wallet),'discord':self.discordToken,'twitter':self.twitterToken,'proxy':self.proxy,'errorMessage':message,'twitterProj':self.twitterReq,'discordProj':self.discordReq,'image':"https://pbs.twimg.com/profile_images/1505785782002339840/mgeaHOqx_400x400.jpg"}
                webhookLog(taskObject)
            return res
        
    
    '''def getNonce(self):
        taskLogger({"status" : "process","message":"Fetching Nonce","prefix":"({},{}) GWEI".format(self.maxGasFee,self.maxPriorityFee)},self.taskId)
        try:
            return web3Connection.eth.get_transaction_count(self.wallet)
        except Exception as e:
            print(e)
            time.sleep(1)
            self.getNonce()

    def transfer(self):
        self.nonce() = 
        body = {
            'nonce' : self.nonce(),
            'to' : self.walletAddress,
            'value' : web3Connection.toWei(0,'ether'),
            'gas' : 21000,
            'maxFeePerGas': web3Connection.toWei(self.maxGasFee,'gwei'),
            'maxPriorityFeePerGas' : web3Connection.toWei(self.maxPriorityFee,'gwei'),
            'chainId':1
        }

        taskLogger({"status" : "warn","message":"Cancelling Transaction","prefix":"({},{}) GWEI".format(self.maxGasFee,self.maxPriorityFee)},self.taskId)
        signedTransaction = web3Connection.eth.account.sign_transaction(body,self.walletKey)
        taskLogger({"status" : "process","message":"Submitting Transaction","prefix":"({},{}) GWEI".format(self.maxGasFee,self.maxPriorityFee)},self.taskId)
        result = web3Connection.eth.send_raw_transaction(signedTransaction.rawTransaction)'''

    def discordMethod(self):
        pass


 


